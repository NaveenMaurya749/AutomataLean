import Mathlib.Computability.ContextFreeGrammar

open ContextFreeGrammar

universe u v w

variable {α β γ : Type*}

/-
# Parse Trees
Parse trees are a way to represent the structure of a string derived from a context-free grammar (CFG).
They are often used in compilers and interpreters to represent the syntactic structure of a program.
-/

/- A parse tree is a tree where each node represents a non-terminal symbol and each leaf represents a terminal symbol. -/
inductive ParseTree (α β : Type*) where
  | leaf : α → ParseTree α β
  | node : β → List (ParseTree α β) → ParseTree α β
deriving Inhabited, Repr

namespace ParseTree

/-- The `map` function applies a function to each leaf of the parse tree. -/
def map {α β γ : Type*} (f : α → β) (t : ParseTree α γ) : ParseTree β γ :=
  match t with
  | leaf a => leaf (f a)
  | node n l => node n (l.map (map f))

def symbolize {α β : Type*} (t : ParseTree α β) : ParseTree (Symbol α β) (Symbol α β) :=
  match t with
  | leaf a => leaf (Symbol.terminal a)
  | node n l => node (Symbol.nonterminal n) (List.map symbolize l)

/-- This function fetches the root of the tree, as a symbol -/
def rootSymbol {α β : Type*} (t : ParseTree α β) : Symbol α β :=
  match t with
  | leaf a => Symbol.terminal a
  | node n _ => Symbol.nonterminal n

/- This checks if a tree is a binary tree -/
def isBinary {α β : Type*} (t : ParseTree α β) : Prop :=
  match t with
  | leaf _ => True
  | node _ l => l.length = 2 ∧ List.foldl And True (List.map isBinary l)

open ContextFreeGrammar

/-This is a function that checks whether a given parse tree is valid according to grammar G. -/
def isParseTreeValid (G : ContextFreeGrammar α) (t : ParseTree α G.NT) : Prop :=
  match t with
  | ParseTree.leaf _ => True
  | ParseTree.node n l => ⟨n, List.map rootSymbol l⟩ ∈ G.rules ∧ List.foldl (fun a b => a ∧ b) True (List.map (isParseTreeValid G) l)

/-
# Chomsky Normal Form
Chomsky Normal Form (CNF) is a simple and useful form of context-free grammar.
A context-free grammar is in CNF if all its production rules are of the form:
1. A → BC (where A, B, and C are non-terminal symbols)
2. A → a (where A is a non-terminal symbol and a is a terminal symbol)
3. S → ε
where S is the start symbol, A is a non-terminal symbol, while B and C are non-terminal symbols excluding S.
-/

@[simp]
def IsChomskyNormal (G : ContextFreeGrammar α) : Prop :=
  ∀ (n : G.NT) (l : List (Symbol α G.NT)), ⟨n, l⟩ ∈ G.rules →
    (l = [] → n = G.initial) ∧
    (l.length = 1 → ∃ (a : α), l = [Symbol.terminal a]) ∧
    (l.length = 2 → ∃ (B C : G.NT), B ≠ G.initial ∧ C ≠ G.initial ∧ l = List.map Symbol.nonterminal [B, C])

structure ChomskyNormalForm (α : Type*) where
  G : ContextFreeGrammar α
  h : IsChomskyNormal G = True

open ChomskyNormalForm

/-
# Theorem
Any context-free language may be generated by a context-free grammar in Chomsky Normal Form
-/
theorem exists_CNF (G : ContextFreeGrammar α) :
  ∃ (G' : ChomskyNormalForm α), G'.1.language = G.language := by
  -- The proof of this theorem is constructive and involves converting the grammar G into CNF.
  -- The details of the conversion process are (non-)trivial and left as an exercise for the reader.
  sorry

/-
# Parse Trees and Chomsky Normal Form
Chomsky Normal Form is useful because
- CNF grammars form a binary tree!
- Binary trees are well-understood and easy to work with.
-/

/-- The yield of a parse tree is the list of terminal symbols that can be obtained by traversing the leaves of the tree. -/
@[simp]
def yield (t : ParseTree α β) : List α :=
  match t with
  | leaf a => [a]
  | node _ l => List.foldl (fun a b => a ++ b.yield) [] l

/-- The height of a parse tree is the length of the longest path from the root to a leaf. -/
@[simp]
def height (t : ParseTree α β) : Nat :=
  match t with
  | leaf _ => 0
  | node _ l => 1 + List.foldl (fun a b => max a b.height) 0 l

/-- Gives the set of all parse trees possible for a string `w` against a grammar `g`-/
@[simp]
def set_parseTrees (G : ContextFreeGrammar α) (w : List α) (h : w ∈ G.language) : Set (ParseTree α G.NT) :=
  { t : ParseTree α G.NT | t.yield = w ∧ isParseTreeValid G t }

/-- Yielding from some valid parse tree is equivalent to being generated by the grammar -/
@[simp]
theorem yields_iff_in_language (G : ContextFreeGrammar α) :
  ∀ w, w ∈ G.language ↔ ∃ (t : ParseTree α G.NT), isParseTreeValid G t ∧ w = t.yield := by
  sorry

/-- All elements in `G.set_parseTrees w h` have valid parse trees -/
@[simp]
theorem parseTree_areParseTree {w} (G : ContextFreeGrammar α) (h : w ∈ G.language) :
  ∀ t, (t ∈ set_parseTrees G w h) → isParseTreeValid G t := by
  sorry

/-- Parse Tree of any string against a grammar in CNF is a binary tree -/
@[simp]
theorem parseTree_of_CNF_binary (CNF : ChomskyNormalForm α) (h : w ∈ CNF.G.language) :
  ∀ t, (t ∈ set_parseTrees CNF.G w h) → isBinary t := by
  sorry

/- Height of a CNF Parse Tree is nonzero -/
@[simp]
lemma height_nonzero (CNF : ChomskyNormalForm α) (t : ParseTree α CNF.G.NT) :
  t.height ≠ 0 := by
  sorry

-- |w| ≤ 2^(n-1)
-- This is purely a combinatorial result
lemma yield_le_exp_n (CNF : ChomskyNormalForm α) (t : ParseTree α CNF.G.NT) :
  t.yield.length ≤ 2 ^ (t.height - 1) := by
  -- The proof of this lemma is based on the properties of CNF and the structure of parse trees.
  -- The details of the proof are left as an exercise for the reader.
  let n := t.height
  cases n with
  | zero => sorry
  | succ n => sorry
  -- The proof involves induction on the height of the parse tree.
